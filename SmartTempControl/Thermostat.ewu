$version 13.04

// Resources
note group Note
{
  attr Bounds = <-70,240,420,680>;
}

$rect <-50,290,150,330>
$output false
resource Resources::Bitmap BackgroundDay
{
  attr bitmapfile FileName = .\Res\BackgroundDay.jpg;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <150,290,350,330>
$output false
resource Resources::Bitmap BackgroundDefault
{
  attr bitmapfile FileName = .\Res\BackgroundDefault.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <-50,330,150,370>
$output false
resource Resources::Bitmap BackgroundNight
{
  attr bitmapfile FileName = .\Res\BackgroundNight.jpg;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <150,330,350,370>
$output false
resource Resources::Bitmap ButtonDay
{
  attr bitmapfile FileName = .\Res\ButtonDay.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <-50,370,150,410>
$output false
resource Resources::Bitmap ButtonNight
{
  attr bitmapfile FileName = .\Res\ButtonNight.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <150,370,350,410>
$output false
resource Resources::Bitmap ButtonVacation
{
  attr bitmapfile FileName = .\Res\ButtonVacation.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <-50,410,150,450>
$output false
resource Resources::Bitmap Controller
{
  attr bitmapfile FileName = .\Res\Controller.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <150,410,350,450>
$output false
resource Resources::Bitmap Needle
{
  attr bitmapfile FileName = .\Res\Needle.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <-50,450,150,490>
$output false
resource Resources::Bitmap SwingSwitch
{
  attr bitmapfile FileName = .\Res\SwingSwitch.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <150,450,350,490>
$output false
resource Resources::Bitmap SymbolFan
{
  attr bitmapfile FileName = .\Res\SymbolFan.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <-50,490,150,530>
$output false
resource Resources::Bitmap SymbolHeadCool
{
  attr bitmapfile FileName = .\Res\SymbolHeadCool.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <150,490,350,530>
$output false
resource Resources::Bitmap VertBar
{
  attr bitmapfile FileName = .\Res\VertBar.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <-50,530,150,570>
$output false
resource Resources::Bitmap Wheels
{
  attr bitmapfile FileName = .\Res\Wheels.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <-370,300,-170,340>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <30,80,230,120>
  inherited method Done()
  {
    // The following section is intended to perform de-initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         de-initialized Thermostat::DeviceClass object. Use the 'thisObject' pointer to
         e.g. de-register the object from the middleware if you have registered it
         beforehand.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           de-initialization steps. For example, you invoke some 'C' function:

             YourDevice_DeInitialize();

           IMPORTANT:
           ----------

           The variable 'thisObject' represents the actually de-initialized instance of the
           Thermostat::DeviceClass. If you have stored this object at the initialization
           time (in the 'Init' method) in some global C variable or registered it by the
           middleware, it is important to perform now the opposite operation. Set the
           global variable to NULL or de-register 'thisObject' object from the middleware.
           
        */
      }
    $endif
  }

  $rect <30,40,230,80>
  inherited method Init()
  {
    // The following section is intended to perform initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         initialized Thermostat::DeviceClass object. Use the 'thisObject' pointer to
         e.g. register the object by the middleware as receiver of events, etc.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           initialization steps. For example, you invoke some 'C' function:

             YourDevice_Initialize();

           The variable 'thisObject' represents the actually initialized instance of the
           Thermostat::DeviceClass. You can store this variable e.g. in the middleware
           and use it whenever the middleware needs to notify the GUI application about
           some state alternation or events. In this manner, the middleware will be able
           to invoke methods of the interface device object.

           For example, you can store 'thisObject' in some global C variable:

             // Declaration of the global C variable
             XObject theDeviceObject;

             // Store the instance in the global variable
             theDeviceObject = thisObject;

           Later use the global variable e.g. to provide the GUI application with events:

             ApplicationDeviceClass__TriggerSomeEvent( theDeviceObject );

           IMPORTANT:
           ----------

           If you store 'thisObject' for later use, don't forget to implement the opposite
           operation in the method 'Done'. Concrete, 'Done' should set the global variable
           again to the value NULL.

        */
      }
    $endif
  }

  // The method 'Init' is executed just in the moment when new instance of 'Thermostat::DeviceClass' \
  // is created. It is suitable to:
  // - initialize the hardware represented by the interface.
  // - register the instance by the middleware to receive updates and events.
  // - open files, network connections or other system resources needed by the interface.
  // 
  // The method 'Done' is executed just in the moment when an instance of 'Thermostat::DeviceClass' \
  // is disposed. It is suitable to:
  // - de-initialize the underlying hardware.
  // - de-register the instance from the underlying middleware.
  // - close files, network connections and other no longer needed system resources.
  // 
  // If your application case doesn't need the initialization or de-initialization, \
  // feel free to delete the methods 'Init' or/and 'Done'.
  note legend Note3
  {
    attr Bounds = <320,0,1100,220>;
  }

  note arrow Note2
  {
    attr Point1 = <250,50>;
    attr Point2 = <320,50>;
  }

  // Constructor and Destructor
  note group Note1
  {
    attr Bounds = <10,0,250,140>;
  }

  $rect <55,254,255,294>
  method int32 UpdateActualTemp( arg int32 aArg1 )
  {
    if ( aNewValue != pure ActualTemp )
    {
      pure ActualTemp = aNewValue;
      notifyobservers ^ActualTemp;
    }
  }

  $rect <50,310,250,350>
  property int32 ActualTemp = 155;

  $rect <50,359,250,399>
  property int32 NominalTemp = 215;

  $rect <290,359,490,399>
  property int32 FanSpeed = 30;

  $rect <519,359,719,399>
  property bool SwingMode = false;

  $rect <740,359,940,399>
  property int32 SettingNo = 0;

  $rect <50,400,250,440>
  onset NominalTemp
  {
    // The property doesn't change -> nothing to do.
    if ( pure NominalTemp == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure NominalTemp = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^NominalTemp;
  }

  $rect <290,400,490,440>
  onset FanSpeed
  {
    // The property doesn't change -> nothing to do.
    if ( pure FanSpeed == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure FanSpeed = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^FanSpeed;
  }

  $rect <519,400,719,440>
  onset SwingMode
  {
    // The property doesn't change -> nothing to do.
    if ( pure SwingMode == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure SwingMode = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^SwingMode;
  }

  $rect <740,400,940,440>
  onset SettingNo
  {
    /* limit to three settings */
    if ( value > 2 )
      value = 2;
    if ( value < 0 )
      value = 0;


    // The property doesn't change -> nothing to do.
    if ( pure SettingNo == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure SettingNo = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^SettingNo;
  }

  $rect <50,470,250,510>
  slot ChangeActualTemp
  {
    var int32 temp = ActualTemp;

    if ( temp < NominalTemp )
      temp = temp + 1;
    else if ( temp > NominalTemp )
      temp = temp - 1;

    UpdateActualTemp( temp );

  }

  $rect <50,510,250,550>
  object Core::Timer ChangeTempTimer
  {
    preset OnTrigger = ChangeActualTemp;
    preset Period = 150;
    preset Enabled = true;
  }
}

$rect <-370,340,-170,380>
autoobject Thermostat::DeviceClass Device;

// Device
note group Note1
{
  attr Bounds = <-400,240,-119,410>;
}

// Constant
note group Note2
{
  attr Bounds = <-400,420,-120,620>;
}

$rect <-370,470,-170,510>
$output false
const color Hot = "";

$rect <-370,510,-170,550>
$output false
const color Cold = "";

// Widgets
note group Note3
{
  attr Bounds = <-400,740,130,1120>;
}

$rect <-370,800,-130,840>
$output false
autoobject WidgetSet::ToggleButtonConfig SwingSwitchConfig
{
  preset FaceOnFrameActive = 3;
  preset FaceOnFrameFocused = 1;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 1;
  preset FaceOnBitmapActive = Thermostat::SwingSwitch;
  preset FaceOnBitmapFocused = Thermostat::SwingSwitch;
  preset FaceOnBitmapDisabled = Thermostat::SwingSwitch;
  preset FaceOnBitmapDefault = Thermostat::SwingSwitch;
  preset FaceOffFrameActive = 2;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 0;
  preset FaceOffBitmapActive = Thermostat::SwingSwitch;
  preset FaceOffBitmapFocused = Thermostat::SwingSwitch;
  preset FaceOffBitmapDisabled = Thermostat::SwingSwitch;
  preset FaceOffBitmapDefault = Thermostat::SwingSwitch;
  preset WidgetMaxSize = <75,44>;
  preset WidgetMinSize = <75,44>;
}

$rect <-370,900,-130,940>
$output false
autoobject WidgetSet::RadioButtonConfig RadioButtonDayConfig
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 50;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = Resources::DefaultFont;
  preset LabelOffFont = Resources::DefaultFont;
  preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop];
  preset FaceOnFrameActive = 1;
  preset FaceOnFrameFocused = 1;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 1;
  preset FaceOnBitmapActive = Thermostat::ButtonDay;
  preset FaceOnBitmapFocused = Thermostat::ButtonDay;
  preset FaceOnBitmapDisabled = Thermostat::ButtonDay;
  preset FaceOnBitmapDefault = Thermostat::ButtonDay;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 0;
  preset FaceOffBitmapActive = Thermostat::ButtonDay;
  preset FaceOffBitmapFocused = Thermostat::ButtonDay;
  preset FaceOffBitmapDisabled = Thermostat::ButtonDay;
  preset FaceOffBitmapDefault = Thermostat::ButtonDay;
  preset WidgetMaxSize = <440,44>;
  preset WidgetMinSize = <44,44>;
}

$rect <-370,950,-130,990>
$output false
autoobject WidgetSet::RadioButtonConfig RadioButtonNightConfig
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 50;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = Resources::DefaultFont;
  preset LabelOffFont = Resources::DefaultFont;
  preset WidgetMaxSize = <440,44>;
  preset WidgetMinSize = <44,44>;
}

$rect <-370,990,-130,1030>
$output false
autoobject WidgetSet::RadioButtonConfig RadioButtonVacConfig
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 50;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = Resources::DefaultFont;
  preset LabelOffFont = Resources::DefaultFont;
  preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop];
  preset FaceOnFrameActive = 1;
  preset FaceOnFrameFocused = 1;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 1;
  preset FaceOnBitmapActive = Thermostat::ButtonVacation;
  preset FaceOnBitmapFocused = Thermostat::ButtonVacation;
  preset FaceOnBitmapDisabled = Thermostat::ButtonVacation;
  preset FaceOnBitmapDefault = Thermostat::ButtonVacation;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 0;
  preset FaceOffBitmapActive = Thermostat::ButtonVacation;
  preset FaceOffBitmapFocused = Thermostat::ButtonVacation;
  preset FaceOffBitmapDisabled = Thermostat::ButtonVacation;
  preset FaceOffBitmapDefault = Thermostat::ButtonVacation;
  preset WidgetMaxSize = <440,44>;
  preset WidgetMinSize = <44,44>;
}

$rect <-370,850,-130,890>
$output false
autoobject WidgetSet::VerticalSliderConfig VerticalSliderConfig
{
  preset TrackBelowFrameActive = 1;
  preset TrackBelowFrameFocused = 1;
  preset TrackBelowFrameDisabled = 1;
  preset TrackBelowFrameDefault = 1;
  preset TrackBelowBitmapActive = Thermostat::VertBar;
  preset TrackBelowBitmapFocused = Thermostat::VertBar;
  preset TrackBelowBitmapDisabled = Thermostat::VertBar;
  preset TrackBelowBitmapDefault = Thermostat::VertBar;
}

// Main Screen and Temp Controller
note group Note4
{
  attr Bounds = <-380,30,20,230>;
}

$rect <-350,80,-150,120>
$output false
class Thermostat : Core::Group
{
  $rect <0,500,200,540>
  inherited property Bounds = <0,0,800,480>;

  $rect <830,-10,1030,30>
  var Thermostat::DeviceClass Device = Thermostat::Device;

  $rect <20,20,160,60>
  object Views::Wallpaper Background
  {
    preset Bounds = <0,0,800,480>;
    preset Bitmap = Thermostat::BackgroundDay;
  }

  $rect <20,20,160,60>
  object Views::Wallpaper Overlay
  {
    preset Bounds = <0,0,800,480>;
    preset Bitmap = Thermostat::BackgroundDay;
    preset Opacity = 0;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <682,406,757,450>;
    preset Outlet = ^Thermostat::Device.SwingMode;
    preset Label = "Caption";
    preset Appearance = Thermostat::SwingSwitchConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioDay
  {
    preset Bounds = <53,23,203,67>;
    preset Outlet = ^Thermostat::Device.SettingNo;
    preset Label = "Day";
    preset Appearance = Thermostat::RadioButtonDayConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioNight
  {
    preset Bounds = <213,20,363,70>;
    preset OutletSelector = 1;
    preset Outlet = ^Thermostat::Device.SettingNo;
    preset Label = "Night";
    preset Appearance = Thermostat::RadioButtonNightConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioVac
  {
    preset Bounds = <400,18,550,68>;
    preset OutletSelector = 2;
    preset Outlet = ^Thermostat::Device.SettingNo;
    preset Label = "Vacation";
    preset Appearance = Thermostat::RadioButtonVacConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalSlider VerticalSlider
  {
    preset Bounds = <733,110,753,330>;
    preset Outlet = ^Thermostat::Device.FanSpeed;
    preset Appearance = Thermostat::VerticalSliderConfig;
  }
}

$rect <-350,130,-150,170>
$output false
class TemperatureController : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,300,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }
}
